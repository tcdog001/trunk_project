#!/bin/bash

if [[ -n "${__UTILS_BASE_IN__}" ]]; then
	return
else
	__UTILS_BASE_IN__="$0"
fi

do_nothing() {
	return
}

do_silent() {
	eval "$@ &> /dev/null"
}

#
#$1:tag
#[$2:info...]
#
do_logger() {
	local tag="$1"; shift

	logger -t "${tag}" "$*"
}

#
#$1:tag
#[$2:info...]
#
echo_logger() {
	echo "$@"
	do_logger "$@"
}

#
#$1:cb
#   cb or ok_cb:err_cb
#$2:tag
#$3:action...
#
do_with_cb() {
	local cb="$1"
	local tag="$2"; shift 2
	local action="$*"
	local err=0

	local ok_cb err_cb
	if [[ "${cb}" == "${cb#*:}" ]]; then
		#
		# cb is NOT include :
		#   so, both ok_cb and err_cb is cb
		#
		ok_cb=${cb}
		err_cb=${cb}
	else
		#
		# cb is include :
		#   so, cb is ok_cb:err_cb
		#
		ok_cb=${cb%:*}; ok_cb=${ok_cb:-do_nothing}
		err_cb=${cb#*:}; err_cb=${err_cb:-do_nothing}
	fi

	eval "${action}"; err=$?
	if ((0==err)); then
		${ok_cb} "${tag}" "OK: ${action}"
	else
		${err_cb} "${tag}" "ERROR[${err}]: ${action}"
	fi

	return ${err}
}

#
#$1:wait
#$2:action...
#
do_while_ok() {
	local wait="$1"; shift
	local action="$*"

	local err=0
	for ((;;)); do
		eval "${action}" && return

		sleep ${wait}
	done
}

get_board_type() {
	cat ${__ROOTFS__}/etc/boardtype
}

#
#$1:board_type
#
__board_check() {
	local board_type="$1"

	if [[ "${board_type}" != "$(get_board_type)" ]]; then
		return 1
	fi
}

ap_board_check() {
	__board_check ap || return $?
}

md_board_check() {
	__board_check md || return $?
}

get_peer() {
	echo "$(get_file_value ${__ROOTFS__}/etc/peer ${PEER})"
}

#
#$1:prefix
#
get_varlist_with_prefix() {
	local prefix="$1"

	eval "echo \${!${prefix}*}"
}

#
#$1:task name
#
gettaskcount() {
	local task=$1
	local count=$(ps | grep ${task} | wc -l)

	((count--))
	echo ${count}

	if ((0==count)); then
		return ${e_noexist}
	fi
}

#
#$1:task
#[$2:app...]
#
monitortask() {
	local task=$1; shift
	local app="$*"
	local count

	count=$(gettaskcount ${task}) || {
		if [[ -z "${app}" ]]; then
			eval "${task} &"
		else
			eval "${app} &"
		fi

		echo_logger "monitor" "monitor ${task} is dead, restart it"
	}
}

#
#$1:lockfile
#$2:action...
#
exec_with_flock() {
	local lockfile="$1"; shift
	local action="$*"
	local err=0

	{
		flock -n 3 || {
			do_logger "flock" \
				"FAILED: cannot lock ${lockfile}"

			return ${e_flock_failed}
		}

		#
		# can NOT eval, the action maybe include json
		#
		${action}; err=$?
	} 3<>${lockfile}

	return ${err}
}


#
#$1:lockfile
#$2:wait
#$3:action...
#
exec_with_flock_wait() {
	local lockfile="$1"
	local wait="$2"; shift 2
	local action="$*"
	local err=0

	{
		flock -w ${wait} 3 || {
			do_logger "flock" \
				"FAILED: cannot lock ${lockfile}"

			return ${e_flock_failed}
		}

		#
		# can NOT eval, the action maybe include json
		#
		${action}; err=$?
	} 3<>${lockfile}

	return ${err}
}

#
#$1:err
#
get_error_tag() {
	local err=$1

	if ((0==err)); then
		echo "OK"
	else
		echo "ERROR[${err}]"
	fi
}

#
#$1:times
#$2:interval
#$3:output
#
display_waiting() {
	local times=$1
	local interval=$2
	local output="$3"
	local i

	for ((i=0; i<times; i++)); do
		echo -e "${output}\c"

		sleep ${interval}
	done
}
